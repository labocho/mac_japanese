require "csv"
require "open-uri"

ROOT_DIR = File.expand_path "#{File.dirname(__FILE__)}/../"

# convert string to literal like "\x81\x40"
def hex_literal(string)
  string.bytes.map{|b|
    "\\x" + b.to_s(16).upcase.rjust(2, "0")
  }.join
end

# convert string to literal like "\u{3041}"
def unicode_literal(string)
  string.codepoints.map{|c|
    "\\u{" + c.to_s(16).upcase.rjust(4, "0") + "}"
  }.join
end

def pua?(four_hex_with_0x)
  case four_hex_with_0x
  when "\u{F860}", "\u{F861}", "\u{F862}", "\u{F87A}", "\u{F87E}", "\u{F87F}"
    true
  else
    false
  end
end

# Make pairs of string literals [[macjapanese, utf8], ...]
def make_pairs(use_pua = true)
  pairs = []
  # Control characters
  pairs += (0x00..0x1f).map{|i|
    c = [i].pack("C*")
    [c, c]
  }
  open("#{ROOT_DIR}/src/JAPANESE.txt") do |f|
    f.lines.each do |line|
      next if line =~ /^#/ # ignore comment
      next unless line =~ /^(0x.+)\t(0x.+)\t/ # capture
      macjp_hex, unicode_hex = $~.captures

      # macjp = macjp_hex[2..-1].chars.each_slice(2).map{|hex| "\\x" + hex.join}.join
      macjp = macjp_hex[2..-1].chars.each_slice(2).map{|h| h.join.to_i(16)}.pack("C*")

      unicode = unicode_hex.split("+").map{|hex|
        c = hex.to_i(16).chr("utf-8")
        next "" if !use_pua && pua?(c) # skip pua
        c
      }.join

      pairs.push [macjp, unicode]
    end
  end
  pairs
end

unless File.exist?("#{ROOT_DIR}/src/JAPANESE.txt")
  open("#{ROOT_DIR}/src/JAPANESE.txt", "w") do |f|
    open("http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/JAPANESE.TXT") do |g|
      f.print g.read
    end
  end
end

# Make MacJapanese to UTF-8 table (with PUA)
path = "#{ROOT_DIR}/lib/mac_japanese/mac_japanese_to_utf8_with_pua.rb"
puts path
literal_pairs = make_pairs.map{|m, u| [hex_literal(m), unicode_literal(u)]}
open(path, "w") do |f|
  f.puts <<-EOS
# This file was automatically generated by `rake tables`.
# Cannot modify directly.
module MacJapanese
  MAC_JAPANESE_TO_UTF8_WITH_PUA = Hash[
    [
#{literal_pairs.map{|m, u| %{      ["#{m}", "#{u}"]}}.join(",\n")}
    ].each{|m, u| m.force_encoding(Encoding::MacJapanese)}
  ]
end
EOS
end

# Make MacJapanese to UTF-8 table (without PUA)
path = "#{ROOT_DIR}/lib/mac_japanese/mac_japanese_to_utf8_without_pua.rb"
puts path
literal_pairs = make_pairs(false).map{|m, u| [hex_literal(m), unicode_literal(u)]}
open(path, "w") do |f|
  f.puts <<-EOS
# This file was automatically generated by `rake tables`.
# Cannot modify directly.
module MacJapanese
  MAC_JAPANESE_TO_UTF8_WITHOUT_PUA = Hash[
    [
#{literal_pairs.map{|m, u| %{      ["#{m}", "#{u}"]}}.join(",\n")}
    ].each{|m, u| m.force_encoding(Encoding::MacJapanese)}
  ]
end
EOS
end

# Make UTF-8 to MacJapanese table
path = "#{ROOT_DIR}/lib/mac_japanese/utf8_to_mac_japanese.rb"
puts path
literal_pairs = make_pairs.map{|m, u| [hex_literal(m), unicode_literal(u)]}
open(path, "w") do |f|
  f.puts <<-EOS
# This file was automatically generated by `rake tables`.
# Cannot modify directly.
module MacJapanese
  UTF8_TO_MAC_JAPANESE = Hash[
    [
#{literal_pairs.map{|m, u| %{      ["#{u}", "#{m}"]}}.join(",\n")}
    ].each{|u, m| m.force_encoding(Encoding::MacJapanese)}
  ]
end
EOS
end

# Make UTF-8 single character or decomposed characters regexp
path = "#{ROOT_DIR}/lib/mac_japanese/decomposed_or_normal_character_regexp.rb"
puts path
decomposed_or_single_character_regexp =
  "/(" + make_pairs.map{|*, u| u}.select{|u| u.size > 1}.map{|u| unicode_literal(u)}.join("|") + "|.)/m"
open(path,  "w") do |f|
  f.puts <<-EOS
# This file was automatically generated by `rake tables`.
# Cannot modify directly.
module MacJapanese
  DECOMPOSED_OR_NORMAL_CHARACTER_REGEXP = #{decomposed_or_single_character_regexp}
end
EOS
end
